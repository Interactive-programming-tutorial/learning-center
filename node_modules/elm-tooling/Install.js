'use strict';

var childProcess = require('child_process');
var crypto = require('crypto');
var fs = require('fs');
var https = require('https');
var path = require('path');
var readline = require('readline');
var zlib = require('zlib');
var os = require('os');

function toJSON(json) {
    return `${JSON.stringify(json, null, 4)}\n`;
}
function isRecord(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
}
function partitionMap(items, f) {
    const left = [];
    const right = [];
    for (const [index, item] of items.entries()) {
        const either = f(item, index, left, right);
        switch (either.tag) {
            case "Left":
                left.push(either.value);
                break;
            case "Right":
                right.push(either.value);
                break;
        }
    }
    return [left, right];
}
const HIDE_CURSOR = "\x1B[?25l";
const SHOW_CURSOR = "\x1B[?25h";
const RESET_COLOR = "\x1B[0m";
function bold(string) {
    return `${RESET_COLOR}\x1B[1m${string}${RESET_COLOR}`;
}
function dim(string) {
    return `${RESET_COLOR}\x1B[2m${string}${RESET_COLOR}`;
}
function removeColor(string) {
    return string.replace(/\x1B\[\dm/g, "");
}
function indent(string) {
    return string.replace(/^/gm, "    ");
}
function printNumErrors(numErrors) {
    return numErrors === 1 ? undefined : `${bold(numErrors.toString())} errors`;
}
// This can be replaced with `Array.prototype.flatMap` once Node.js is EOL
// 2021-04-30 and support for Node.js 10 is dropped.
function flatMap(array, callback) {
    const results = [];
    for (const [index, item] of array.entries()) {
        const result = callback(item, index, array);
        if (Array.isArray(result)) {
            results.push(...result);
        }
        else {
            results.push(result);
        }
    }
    return results;
}
// This can be replaced with `Object.fromEntries` once Node.js is EOL
// 2021-04-30 and support for Node.js 10 is dropped.
function fromEntries(entries) {
    const result = {};
    for (const [key, value] of entries) {
        result[key] = value;
    }
    return result;
}
function split(string, regex) {
    return string.split(regex);
}
function getOwn(record, key) {
    return Object.prototype.hasOwnProperty.call(record, key)
        ? record[key]
        : undefined;
}
function isNonEmptyArray(array) {
    return array.length >= 1;
}
/**
 * More type safe version of `Array#join`.
 */
function join(array, separator) {
    return array.join(separator);
}
function toError(arg) {
    return toError.jestWorkaround(arg);
}
// Workaround for https://github.com/facebook/jest/issues/2549
// In the tests we set this to always return `arg as Error`.
// istanbul ignore next
toError.jestWorkaround = (arg) => arg instanceof Error
    ? arg
    : new Error(`Caught error not instanceof Error: ${String(arg)}`);

const knownTools = {
    elm: {
        "0.19.0": {
            linux: {
                hash: "d359adbee89823c641cda326938708d7227dc79aa1f162e0d8fe275f182f528a",
                url: "https://github.com/elm/compiler/releases/download/0.19.0/binary-for-linux-64-bit.gz",
                fileSize: 10958261,
                fileName: "elm",
                type: "gz",
            },
            mac: {
                hash: "f1fa4dd9021e94c5a58b2be8843e3329095232ee3bd21a23524721a40eaabd35",
                url: "https://github.com/elm/compiler/releases/download/0.19.0/binary-for-mac-64-bit.gz",
                fileSize: 6051435,
                fileName: "elm",
                type: "gz",
            },
            windows: {
                hash: "0e27d80537418896cf98326224159a45b6d36bf08e608e3a174ab6d2c572c5ae",
                url: "https://github.com/elm/compiler/releases/download/0.19.0/binary-for-windows-64-bit.gz",
                fileSize: 12639872,
                fileName: "elm.exe",
                type: "gz",
            },
        },
        "0.19.1": {
            linux: {
                hash: "e44af52bb27f725a973478e589d990a6428e115fe1bb14f03833134d6c0f155c",
                url: "https://github.com/elm/compiler/releases/download/0.19.1/binary-for-linux-64-bit.gz",
                fileSize: 6806857,
                fileName: "elm",
                type: "gz",
            },
            mac: {
                hash: "05289f0e3d4f30033487c05e689964c3bb17c0c48012510dbef1df43868545d1",
                url: "https://github.com/elm/compiler/releases/download/0.19.1/binary-for-mac-64-bit.gz",
                fileSize: 6034616,
                fileName: "elm",
                type: "gz",
            },
            windows: {
                hash: "d1bf666298cbe3c5447b9ca0ea608552d750e5d232f9845c2af11907b654903b",
                url: "https://github.com/elm/compiler/releases/download/0.19.1/binary-for-windows-64-bit.gz",
                fileSize: 12727488,
                fileName: "elm.exe",
                type: "gz",
            },
        },
    },
    "elm-format": {
        "0.8.1": {
            linux: {
                hash: "13d06e0c3f3a9ef585c828ac5761ead148ea2f203573309306393e2d8066e1fd",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.1/elm-format-0.8.1-linux-x64.tgz",
                fileSize: 2110405,
                fileName: "elm-format",
                type: "tgz",
            },
            mac: {
                hash: "e1beba5d3090968cbbd879384617506f4c71a3ea3b01ce94d298e4893e82a640",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.1/elm-format-0.8.1-mac-x64.tgz",
                fileSize: 1325147,
                fileName: "elm-format",
                type: "tgz",
            },
            windows: {
                hash: "29b8989918e5804b538c411a92f3da8d15337ec28003b033b3be0de2d2d636d2",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.1/elm-format-0.8.1-win-i386.zip",
                fileSize: 2281778,
                fileName: "elm-format.exe",
                type: "zip",
            },
        },
        "0.8.2": {
            linux: {
                hash: "a69a4d3c49ccb0dffb3067b35464dc492563274e5778c40625220f9f6b3fd06d",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.2/elm-format-0.8.2-linux-x64.tgz",
                fileSize: 2128375,
                fileName: "elm-format",
                type: "tgz",
            },
            mac: {
                hash: "1f6cc8663922e546645c0536fc9bf7a49351d0b2963d26fc8fcb43e5bc92d733",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.2/elm-format-0.8.2-mac-x64.tgz",
                fileSize: 1298447,
                fileName: "elm-format",
                type: "tgz",
            },
            windows: {
                hash: "5009fd26b59a785738dd82c8d90ea8fd0bb7fe65fbd562097d906ee04061ef7f",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.2/elm-format-0.8.2-win-i386.zip",
                fileSize: 4243045,
                fileName: "elm-format.exe",
                type: "zip",
            },
        },
        "0.8.3": {
            linux: {
                hash: "9012f3a372488d4a118dc5f8ff57cc61cd1753d7d878b393fa7f60d496e37084",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.3/elm-format-0.8.3-linux-x64.tgz",
                fileSize: 2137733,
                fileName: "elm-format",
                type: "tgz",
            },
            mac: {
                hash: "66c9d4c2fcc7e435726f25ca44509cdf2caff5000dd215b5a086db514576efc7",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.3/elm-format-0.8.3-mac-x64.tgz",
                fileSize: 1308986,
                fileName: "elm-format",
                type: "tgz",
            },
            windows: {
                hash: "da9c013e27faccd14d6395db638af111097f171a45705a8978a28e30c115778f",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.3/elm-format-0.8.3-win-i386.zip",
                fileSize: 4136741,
                fileName: "elm-format.exe",
                type: "zip",
            },
        },
        "0.8.4": {
            linux: {
                hash: "aa6bb9d11672d8d27398746e831266c565e9837b4da6abe5d8286c2ab69ace9d",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.4/elm-format-0.8.4-linux-x64.tgz",
                fileSize: 1956444,
                fileName: "elm-format",
                type: "tgz",
            },
            mac: {
                hash: "df2a85da6870e8c8f7b052c9b81279fd9cbbab2bc738c2e14adf95ef777edd21",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.4/elm-format-0.8.4-mac-x64.tgz",
                fileSize: 1283871,
                fileName: "elm-format",
                type: "tgz",
            },
            windows: {
                hash: "0afe91bba2951c675f7484ae8d3d45792ed802d2eac9110b2afc18e3ed1a888d",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.4/elm-format-0.8.4-win-x64.zip",
                fileSize: 2105708,
                fileName: "elm-format.exe",
                type: "zip",
            },
        },
        "0.8.5": {
            linux: {
                hash: "147c479e375b9bae8dd633e526677fbd2a87e5445b3638ebee86c1319ffe8e23",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.5/elm-format-0.8.5-linux-x64.tgz",
                fileSize: 3870971,
                fileName: "elm-format",
                type: "tgz",
            },
            mac: {
                hash: "380c5f36b1fdeb2f1cda7c208dc788cb676675b3d5d43d907efc3f0821c010d6",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.5/elm-format-0.8.5-mac-x64.tgz",
                fileSize: 1334367,
                fileName: "elm-format",
                type: "tgz",
            },
            windows: {
                hash: "3cb6f74f24b401314480227b1ccbb2049cceb4a365ac7abb50cd3cfe0e64bbdc",
                url: "https://github.com/avh4/elm-format/releases/download/0.8.5/elm-format-0.8.5-win-x64.zip",
                fileSize: 1737291,
                fileName: "elm-format.exe",
                type: "zip",
            },
        },
    },
    "elm-json": {
        "0.2.8": {
            linux: {
                hash: "d4561a9a2bd70e1a4a4c61e75cac03d3bb1a3b5f99322afa720a2f2d84c194de",
                url: "https://github.com/zwilias/elm-json/releases/download/v0.2.8/elm-json-v0.2.8-x86_64-unknown-linux-musl.tar.gz",
                fileSize: 2255688,
                fileName: "elm-json",
                type: "tgz",
            },
            mac: {
                hash: "1ca3cde58730e87f2b73afb2432d5d8c88787ee3745bc81769ec0eef962ceaf6",
                url: "https://github.com/zwilias/elm-json/releases/download/v0.2.8/elm-json-v0.2.8-x86_64-apple-darwin.tar.gz",
                fileSize: 838159,
                fileName: "elm-json",
                type: "tgz",
            },
            windows: {
                hash: "1ae0b8e9a9717bdfb05346d0b864868e3907cb83c54d6770f6c604972296384f",
                url: "https://github.com/zwilias/elm-json/releases/download/v0.2.8/elm-json-v0.2.8-x86_64-pc-windows-msvc.tar.gz",
                fileSize: 1375556,
                fileName: "elm-json.exe",
                type: "tgz",
            },
        },
        "0.2.10": {
            linux: {
                hash: "6ee94f04bebeb66d5ef322d76fd3dc828015571b92f1259776f716feaaec359d",
                url: "https://github.com/zwilias/elm-json/releases/download/v0.2.10/elm-json-v0.2.10-x86_64-unknown-linux-musl.tar.gz",
                fileSize: 2307188,
                fileName: "elm-json",
                type: "tgz",
            },
            mac: {
                hash: "fcd39c7c014d95df033499d8a39720b38c9f93d0e3b7ecb821cfe3dbfd1affc1",
                url: "https://github.com/zwilias/elm-json/releases/download/v0.2.10/elm-json-v0.2.10-x86_64-apple-darwin.tar.gz",
                fileSize: 899328,
                fileName: "elm-json",
                type: "tgz",
            },
            windows: {
                hash: "721084dd90042a2b7b99a1334a9dcfa753fcf166ade458e6a3bb5d6649f8e39b",
                url: "https://github.com/zwilias/elm-json/releases/download/v0.2.10/elm-json-v0.2.10-x86_64-pc-windows-msvc.tar.gz",
                fileSize: 1415941,
                fileName: "elm-json.exe",
                type: "tgz",
            },
        },
    },
    "elm-test-rs": {
        "1.0.0": {
            linux: {
                hash: "a914088083ea8bc004944c98d9a4767cc5225d5811480f49fe1ad2c491baaaaa",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.0/elm-test-rs_linux.tar.gz",
                fileSize: 3610634,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            mac: {
                hash: "5f296888b7ba32c47830f00f6d38c56fc86f49d8c0c8998054b0842009a1173f",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.0/elm-test-rs_macos.tar.gz",
                fileSize: 2230430,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            windows: {
                hash: "c8a35e2e0049b691e4833a6e8ccb094688cdc49aa977c437a8289c57d92a5775",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.0/elm-test-rs_windows.zip",
                fileSize: 1939029,
                fileName: "elm-test-rs.exe",
                type: "zip",
            },
        },
        "1.2.1": {
            linux: {
                hash: "6e5759f832a5e025898c9306ba47b2f9ed7f0c371dc69bd16c15c7ed8bfb1501",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.2.1/elm-test-rs_linux.tar.gz",
                fileSize: 3591932,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            mac: {
                hash: "890c45a7eda24fd13169d349af9c835ee3ed04974eec36953baba5aefc3628a8",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.2.1/elm-test-rs_macos.tar.gz",
                fileSize: 2221267,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            windows: {
                hash: "26add13880af484a47cd182547f41370d3bfca812a7cc9e3db6f41ce13b7fc40",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.2.1/elm-test-rs_windows.zip",
                fileSize: 1880965,
                fileName: "elm-test-rs.exe",
                type: "zip",
            },
        },
        "1.2.2": {
            linux: {
                hash: "f9b972b9dcb71b9957baf23e5bca5674dfdea73b4b3706ad2c501f507933e489",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.2.2/elm-test-rs_linux.tar.gz",
                fileSize: 3629469,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            mac: {
                hash: "d3dc5f84a2b3c31a4a14a9da609c2f2e6824102d30249f883a97ea26c4eb9c35",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.2.2/elm-test-rs_macos.tar.gz",
                fileSize: 2227354,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            windows: {
                hash: "8469a05cdaf0be76e7cb7c9d8001a88df74a1db964a24d144554a925f8042600",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v1.2.2/elm-test-rs_windows.zip",
                fileSize: 1891939,
                fileName: "elm-test-rs.exe",
                type: "zip",
            },
        },
        "2.0.0": {
            linux: {
                hash: "face27bfe2b886d3ba96ad77c3f52d312da0f6089163b6db1b1c76297518ec54",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v2.0/elm-test-rs_linux.tar.gz",
                fileSize: 3572480,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            mac: {
                hash: "b8a5c487d7fc60c3bbb40bf8616b4da726ce0ad867ea6295a07a4726f9fe105a",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v2.0/elm-test-rs_macos.tar.gz",
                fileSize: 2233532,
                fileName: "elm-test-rs",
                type: "tgz",
            },
            windows: {
                hash: "5f4ae45981750ac17cd72a2711bacc21fee763840d3f18c2e73614666f510ee8",
                url: "https://github.com/mpizenberg/elm-test-rs/releases/download/v2.0/elm-test-rs_windows.zip",
                fileSize: 1897927,
                fileName: "elm-test-rs.exe",
                type: "zip",
            },
        },
    },
};
const KNOWN_TOOLS = knownTools;
const KNOWN_TOOL_NAMES = Object.keys(KNOWN_TOOLS);
function getLastVersion(name) {
    const versions = Object.keys(KNOWN_TOOLS[name]);
    // We know that all tools in this file has at least one version.
    return versions[versions.length - 1];
}

function absolutePathFromString(from, pathString) {
    return {
        tag: "AbsolutePath",
        absolutePath: path.resolve(from.absolutePath, pathString),
    };
}
function absoluteDirname({ absolutePath }) {
    return {
        tag: "AbsolutePath",
        absolutePath: path.dirname(absolutePath),
    };
}
function findClosest(name, absoluteDir) {
    const dir = absoluteDir.absolutePath;
    const entry = path.join(dir, name);
    return fs.existsSync(entry)
        ? { tag: "AbsolutePath", absolutePath: entry }
        : dir === path.parse(dir).root
            ? undefined
            : findClosest(name, absoluteDirname(absoluteDir));
}
function getNodeModulesBinPath(elmToolingJsonPath) {
    return {
        tag: "NodeModulesBinPath",
        theNodeModulesBinPath: absolutePathFromString(absoluteDirname(elmToolingJsonPath.theElmToolingJsonPath), path.join("node_modules", ".bin")),
    };
}

const isWindows = os.platform() === "win32";
function getElmToolingInstallPath(cwd, env) {
    var _a, _b;
    // istanbul ignore next
    const elmHome = (_a = env.ELM_HOME) !== null && _a !== void 0 ? _a : (isWindows
        ? path.join((_b = env.APPDATA) !== null && _b !== void 0 ? _b : path.join(os.homedir(), "AppData", "Roaming"), "elm")
        : path.join(os.homedir(), ".elm"));
    return absolutePathFromString(cwd.path, path.join(elmHome, "elm-tooling"));
}
function findReadAndParseElmToolingJson(cwd, env) {
    const elmToolingJsonPathRaw = findClosest("elm-tooling.json", cwd.path);
    if (elmToolingJsonPathRaw === undefined) {
        return {
            tag: "ElmToolingJsonNotFound",
            message: "No elm-tooling.json found. To create one: elm-tooling init",
        };
    }
    const elmToolingJsonPath = {
        tag: "ElmToolingJsonPath",
        theElmToolingJsonPath: elmToolingJsonPathRaw,
    };
    let json = undefined;
    try {
        json = JSON.parse(fs.readFileSync(elmToolingJsonPath.theElmToolingJsonPath.absolutePath, "utf-8"));
    }
    catch (unknownError) {
        const error = toError(unknownError);
        return {
            tag: "ReadAsJsonObjectError",
            elmToolingJsonPath,
            errors: [
                {
                    tag: "Message",
                    message: `Failed to read file as JSON:\n${error.message}`,
                },
            ],
        };
    }
    if (!isRecord(json)) {
        return {
            tag: "ReadAsJsonObjectError",
            elmToolingJsonPath,
            errors: [
                {
                    tag: "Message",
                    message: `Expected an object but got: ${JSON.stringify(json)}`,
                },
            ],
        };
    }
    const osName = getOSName();
    // istanbul ignore if
    if (osName instanceof Error) {
        return {
            tag: "ReadAsJsonObjectError",
            elmToolingJsonPath,
            errors: [
                {
                    tag: "Message",
                    message: osName.message,
                },
            ],
        };
    }
    const result = {
        tag: "Parsed",
        elmToolingJsonPath,
        originalObject: json,
        osName,
    };
    const errors = [];
    for (const [field, value] of Object.entries(json)) {
        switch (field) {
            // Ignored for legacy reasons.
            case "entrypoints":
                break;
            case "tools": {
                const toolsResult = parseTools(cwd, env, osName, value);
                if (Array.isArray(toolsResult)) {
                    errors.push(...toolsResult);
                }
                else {
                    result.tools = toolsResult;
                }
                break;
            }
            default:
                errors.push({ tag: "UnkownField", field });
                break;
        }
    }
    if (isNonEmptyArray(errors)) {
        return {
            tag: "ReadAsJsonObjectError",
            elmToolingJsonPath,
            errors,
        };
    }
    return result;
}
function getOSName() {
    // istanbul ignore next
    switch (os.platform()) {
        case "linux":
            return "linux";
        case "darwin":
            return "mac";
        case "win32":
            return "windows";
        default:
            return new Error(`Sorry, your platform (${os.platform()}) is not supported yet :(`);
    }
}
function validateFileExists(fullPath) {
    try {
        const stats = fs.statSync(fullPath.absolutePath);
        if (!stats.isFile()) {
            return {
                tag: "Error",
                message: `Exists but is not a file: ${fullPath.absolutePath}`,
            };
        }
    }
    catch (unknownError) {
        const error = toError(unknownError);
        switch (error.code) {
            case "ENOENT":
                return {
                    tag: "DoesNotExist",
                    message: `File does not exist: ${fullPath.absolutePath}`,
                };
            case "ENOTDIR":
                return {
                    tag: "Error",
                    message: `A part of this path exist, but is not a directory (which it needs to be): ${absoluteDirname(fullPath).absolutePath}`,
                };
            // istanbul ignore next
            default:
                return {
                    tag: "Error",
                    message: `File error for ${fullPath.absolutePath}: ${error.message}`,
                };
        }
    }
    return { tag: "Exists" };
}
function parseTools(cwd, env, osName, json) {
    if (!isRecord(json)) {
        return [
            {
                tag: "WithPath",
                path: ["tools"],
                message: `Expected an object but got: ${JSON.stringify(json)}`,
            },
        ];
    }
    const [errors, tools] = partitionMap(Object.entries(json), ([name, version]) => {
        if (typeof version !== "string") {
            return {
                tag: "Left",
                value: {
                    tag: "WithPath",
                    path: ["tools", name],
                    message: `Expected a version as a string but got: ${JSON.stringify(version)}`,
                },
            };
        }
        const versions = getOwn(KNOWN_TOOLS, name);
        if (versions === undefined) {
            return {
                tag: "Left",
                value: {
                    tag: "WithPath",
                    path: ["tools", name],
                    message: `Unknown tool\nKnown tools: ${join(KNOWN_TOOL_NAMES, ", ")}`,
                },
            };
        }
        const osAssets = getOwn(versions, version);
        if (osAssets === undefined) {
            return {
                tag: "Left",
                value: {
                    tag: "WithPath",
                    path: ["tools", name],
                    message: `Unknown version: ${version}\nKnown versions: ${join(Object.keys(versions), ", ")}`,
                },
            };
        }
        const asset = osAssets[osName];
        const tool = makeTool(cwd, env, name, version, asset);
        const exists = validateFileExists(tool.location.theToolPath);
        switch (exists.tag) {
            case "Exists":
                return {
                    tag: "Right",
                    value: { exists: true, tool },
                };
            case "DoesNotExist":
                return {
                    tag: "Right",
                    value: { exists: false, tool },
                };
            case "Error":
                return {
                    tag: "Left",
                    value: {
                        tag: "WithPath",
                        path: ["tools", name],
                        message: exists.message,
                    },
                };
        }
    });
    if (isNonEmptyArray(errors)) {
        return errors;
    }
    const [existing, missing] = partitionMap(tools, ({ exists, tool }) => exists ? { tag: "Left", value: tool } : { tag: "Right", value: tool });
    return { existing, missing };
}
function makeTool(cwd, env, name, version, asset) {
    return {
        name,
        version,
        location: {
            tag: "ToolPath",
            theToolPath: absolutePathFromString(getElmToolingInstallPath(cwd, env), path.join(name, version, asset.fileName)),
        },
        asset,
    };
}
function printParseErrors(errors) {
    return join(flatMap([
        printNumErrors(errors.length),
        ...errors.map((error) => {
            switch (error.tag) {
                case "Message":
                    return error.message;
                case "UnkownField":
                    return `${bold(error.field)}\n${indent("Unknown field")}`;
                case "WithPath":
                    return `${bold(joinPath(error.path))}\n${indent(error.message)}`;
            }
        }),
    ], (item) => (item === undefined ? [] : [item])), "\n\n");
}
function joinPath(errorPath) {
    // istanbul ignore if
    if (!isNonEmptyArray(errorPath)) {
        return "General";
    }
    const rest = errorPath
        .slice(1)
        .map((segment) => `[${JSON.stringify(segment)}]`);
    return `${errorPath[0]}${join(rest, "")}`;
}
const versionRangeRegex = /^([=~^])(\d+)\.(\d+)\.(\d+)([+-].+)?$/;
const prereleaseRegex = /-.+$/;
const collator = new Intl.Collator("en", { numeric: true });
function hasPrerelease(version) {
    var _a;
    return ((_a = /[+-]/.exec(version)) === null || _a === void 0 ? void 0 : _a[0]) === "-";
}
function hasSameBase(a, b) {
    return a.replace(prereleaseRegex, "") === b.replace(prereleaseRegex, "");
}
function getToolThrowing({ name, version: versionRange, cwd, env, }) {
    const osName = getOSName();
    // istanbul ignore if
    if (osName instanceof Error) {
        throw osName;
    }
    const versions = getOwn(KNOWN_TOOLS, name);
    if (versions === undefined) {
        throw new Error(`Unknown tool: ${name}\nKnown tools: ${join(KNOWN_TOOL_NAMES, ", ")}`);
    }
    const matchingVersion = getLatestMatchingVersion(versionRange, Object.keys(versions).reverse());
    if (matchingVersion === undefined) {
        throw new Error(`No ${name} versions matching: ${versionRange}\nKnown versions: ${join(Object.keys(versions), ", ")}`);
    }
    // `matchingVersion` is derived from `Object.keys` above, so it’s safe to use
    // as index.
    const asset = versions[matchingVersion][osName];
    return makeTool(cwd, env, name, matchingVersion, asset);
}
function getLatestMatchingVersion(versionRange, sortedValidVersions) {
    const match = versionRangeRegex.exec(versionRange);
    if (match === null) {
        throw new Error(`Version ranges must start with ^ or ~ (or = if you really need an exact version) and be followed by 3 dot-separated numbers, but got: ${versionRange}`);
    }
    const sign = match[1];
    const major = Number(match[2]);
    const minor = Number(match[3]);
    const lowerBoundInclusive = versionRange.slice(1);
    const upperBoundExclusive = major === 0 || sign === "~"
        ? `${major}.${minor + 1}.0`
        : `${major + 1}.0.0`;
    return sign === "="
        ? sortedValidVersions.find((version) => version === lowerBoundInclusive)
        : getLatestVersionInRange(lowerBoundInclusive, upperBoundExclusive, sortedValidVersions);
}
function getLatestVersionInRange(lowerBoundInclusive, upperBoundExclusive, sortedValidVersions) {
    return sortedValidVersions.find((version) => {
        // For example, `^0.19.1-rc` should not match `0.19.2-alpha`.
        // And `^0.19.1` should not match `0.19.2-alpha`.
        if (
        // Known prereleases can only be matched…
        hasPrerelease(version) &&
            // …if the lower bound mentions a prerelease…
            !(hasPrerelease(lowerBoundInclusive) &&
                // …and both are for the same base version.
                hasSameBase(version, lowerBoundInclusive))) {
            // If not (via the `!` above), don’t try to match this version.
            return false;
        }
        // For example, `^0.19.1-rc` should match `0.19.1`.
        if (!hasPrerelease(version) &&
            hasPrerelease(lowerBoundInclusive) &&
            hasSameBase(version, lowerBoundInclusive)) {
            return true;
        }
        return (collator.compare(version, lowerBoundInclusive) >= 0 &&
            collator.compare(version, upperBoundExclusive) < 0);
    });
}

function linkTool(cwd, nodeModulesBinPath, tool) {
    const { linkPathPresentationString, what, strategy } = linkHelper(cwd, nodeModulesBinPath, tool);
    const result = linkToolWithStrategy(tool, strategy);
    if (result instanceof Error) {
        return new Error(result.message);
    }
    switch (result) {
        case "AllGood":
            return `${bold(`${tool.name} ${tool.version}`)}: ${dim("all good")}`;
        case "Created":
            return `${bold(`${tool.name} ${tool.version}`)} ${what} created: ${dim(`${linkPathPresentationString} -> ${tool.location.theToolPath.absolutePath}`)}\n${indent(`To run: npx ${tool.name}`)}`;
    }
}
// Just like npm, these overwrite whatever links are already in
// `node_modules/.bin/`. Most likely it’s either old links from for example the
// `elm` npm package, or links from previous runs of this script.
function linkToolWithStrategy(tool, strategy) {
    switch (strategy.tag) {
        case "Link":
            return symlink(tool, strategy.linkPath);
        // istanbul ignore next
        case "Shims":
            return symlinkShimWindows(tool, strategy.items);
    }
}
function unlinkTool(cwd, nodeModulesBinPath, tool) {
    const { linkPathPresentationString, what, strategy } = linkHelper(cwd, nodeModulesBinPath, tool);
    const result = unlinkToolWithStrategy(tool, strategy);
    // istanbul ignore if
    if (result instanceof Error) {
        return new Error(result.message);
    }
    switch (result) {
        case "DidNothing":
            return undefined;
        case "Removed":
            return `${bold(`${tool.name} ${tool.version}`)} ${what} removed: ${dim(`${linkPathPresentationString}`)}`;
    }
}
// These only remove things that are created by elm-tooling itself (or seem to
// be). For example, if the user has installed elm-json with npm we shouldn’t
// remove that link.
function unlinkToolWithStrategy(tool, strategy) {
    switch (strategy.tag) {
        case "Link":
            return removeSymlink(tool, strategy.linkPath);
        // istanbul ignore next
        case "Shims":
            return removeSymlinkShimWindows(tool, strategy.items);
    }
}
function linkHelper(cwd, nodeModulesBinPath, tool) {
    const linkPath = {
        tag: "LinkPath",
        theLinkPath: absolutePathFromString(nodeModulesBinPath.theNodeModulesBinPath, tool.name),
    };
    const relativeLinkPath = path.relative(cwd.path.absolutePath, linkPath.theLinkPath.absolutePath);
    const possiblyRelativeLinkPath = relativeLinkPath.startsWith("node_modules")
        ? relativeLinkPath
        : linkPath.theLinkPath.absolutePath;
    // istanbul ignore if
    if (isWindows) {
        return {
            linkPathPresentationString: `${possiblyRelativeLinkPath}{,.cmd,.ps1}`,
            what: "shims",
            strategy: {
                tag: "Shims",
                items: [
                    {
                        shimPath: makeShimPath(linkPath, ""),
                        code: makeShScript(tool.location),
                    },
                    {
                        shimPath: makeShimPath(linkPath, ".cmd"),
                        code: makeCmdScript(tool.location),
                    },
                    {
                        shimPath: makeShimPath(linkPath, ".ps1"),
                        code: makePs1Script(tool.location),
                    },
                ],
            },
        };
    }
    return {
        linkPathPresentationString: possiblyRelativeLinkPath,
        what: "link",
        strategy: { tag: "Link", linkPath },
    };
}
function symlink(tool, linkPath) {
    try {
        if (fs.readlinkSync(linkPath.theLinkPath.absolutePath) ===
            tool.location.theToolPath.absolutePath) {
            return "AllGood";
        }
    }
    catch (_error) {
        // Continue below.
    }
    try {
        fs.unlinkSync(linkPath.theLinkPath.absolutePath);
    }
    catch (unknownError) {
        const error = toError(unknownError);
        if (error.code !== "ENOENT") {
            return new Error(`Failed to remove old link for ${tool.name} at ${linkPath.theLinkPath.absolutePath}:\n${error.message}`);
        }
    }
    try {
        fs.symlinkSync(tool.location.theToolPath.absolutePath, linkPath.theLinkPath.absolutePath);
    }
    catch (unknownError) /* istanbul ignore next */ {
        const error = toError(unknownError);
        return new Error(`Failed to create link for ${tool.name} at ${linkPath.theLinkPath.absolutePath}:\n${error.message}`);
    }
    return "Created";
}
function removeSymlink(tool, linkPath) {
    try {
        if (fs.readlinkSync(linkPath.theLinkPath.absolutePath) ===
            tool.location.theToolPath.absolutePath) {
            fs.unlinkSync(linkPath.theLinkPath.absolutePath);
            return "Removed";
        }
    }
    catch (unknownError) {
        const error = toError(unknownError);
        // If the path exists but is something else, let it be.
        // If the path does not exist there’s nothing to do.
        // istanbul ignore if
        if (error.code !== "EINVAL" && error.code !== "ENOENT") {
            return new Error(`Failed to remove old link for ${tool.name} at ${linkPath.theLinkPath.absolutePath}:\n${error.message}`);
        }
    }
    return "DidNothing";
}
// istanbul ignore next
function symlinkShimWindows(tool, items) {
    try {
        if (items.every(({ shimPath, code }) => fs.readFileSync(shimPath.theShimPath.absolutePath, "utf8") === code)) {
            return "AllGood";
        }
    }
    catch (_error) {
        // Continue below.
    }
    for (const { shimPath } of items) {
        try {
            fs.unlinkSync(shimPath.theShimPath.absolutePath);
        }
        catch (unknownError) {
            const error = toError(unknownError);
            if (error.code !== "ENOENT") {
                return new Error(`Failed to remove old shim for ${tool.name} at ${shimPath.theShimPath.absolutePath}:\n${error.message}`);
            }
        }
    }
    for (const { shimPath, code } of items) {
        try {
            fs.writeFileSync(shimPath.theShimPath.absolutePath, code);
        }
        catch (unknownError) {
            const error = toError(unknownError);
            return new Error(`Failed to create shim for ${tool.name} at ${shimPath.theShimPath.absolutePath}:\n${error.message}`);
        }
    }
    return "Created";
}
// istanbul ignore next
function removeSymlinkShimWindows(tool, items) {
    let didNothing = true;
    for (const { shimPath, code } of items) {
        try {
            if (fs.readFileSync(shimPath.theShimPath.absolutePath, "utf8") === code) {
                fs.unlinkSync(shimPath.theShimPath.absolutePath);
                didNothing = false;
            }
        }
        catch (unknownError) {
            const error = toError(unknownError);
            // If the path exists but isn’t a file, let it be.
            // If the path does not exists there’s nothing to do.
            if (error.code !== "EISDIR" && error.code !== "ENOENT") {
                return new Error(`Failed to remove old shim for ${tool.name} at ${shimPath.theShimPath.absolutePath}:\n${error.message}`);
            }
        }
    }
    return didNothing ? "DidNothing" : "Removed";
}
// istanbul ignore next
function makeShimPath(linkPath, suffix) {
    return {
        tag: "ShimPath",
        theShimPath: {
            tag: "AbsolutePath",
            absolutePath: linkPath.theLinkPath.absolutePath + suffix,
        },
    };
}
// Windows-style paths works fine, at least in Git bash.
function makeShScript(toolPath) {
    return lf(`
#!/bin/sh
${join(toolPath.theToolPath.absolutePath
        .split(/(')/)
        .map((segment) => segment === "" ? "" : segment === "'" ? "\\'" : `'${segment}'`), "")} "$@"
`);
}
// Note: Paths on Windows cannot contain `"`.
function makeCmdScript(toolPath) {
    return crlf(`
@ECHO off
"${toolPath.theToolPath.absolutePath}" %*
`);
}
// The shebang is for PowerShell on unix: https://github.com/npm/cmd-shim/pull/34
function makePs1Script(toolPath) {
    return lf(`
#!/usr/bin/env pwsh
& '${toolPath.theToolPath.absolutePath.replace(/'/g, "''")}' $args
`);
}
function lf(string) {
    return `${string.trim()}\n`;
}
function crlf(string) {
    return lf(string).replace(/\n/g, "\r\n");
}

const EMPTY_STDERR = dim("(empty stderr)");
async function install(cwd, env, logger) {
    if ("NO_ELM_TOOLING_INSTALL" in env) {
        return 0;
    }
    const parseResult = findReadAndParseElmToolingJson(cwd, env);
    switch (parseResult.tag) {
        case "ElmToolingJsonNotFound":
            logger.error(parseResult.message);
            return 1;
        case "ReadAsJsonObjectError":
            logger.error(bold(parseResult.elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
            logger.error("");
            logger.error(printParseErrors(parseResult.errors));
            return 1;
        case "Parsed": {
            if (parseResult.tools === undefined) {
                return removeAllTools(cwd, env, logger, parseResult.osName, parseResult.elmToolingJsonPath, "missing");
            }
            const { tools } = parseResult;
            if (tools.existing.length === 0 && tools.missing.length === 0) {
                return removeAllTools(cwd, env, logger, parseResult.osName, parseResult.elmToolingJsonPath, "empty");
            }
            return installTools(cwd, env, logger, parseResult.elmToolingJsonPath, parseResult.osName, tools);
        }
    }
}
async function installTools(cwd, env, logger, elmToolingJsonPath, osName, tools) {
    const nodeModulesBinPath = getNodeModulesBinPath(elmToolingJsonPath);
    try {
        fs.mkdirSync(nodeModulesBinPath.theNodeModulesBinPath.absolutePath, {
            recursive: true,
        });
    }
    catch (unknownError) {
        const error = toError(unknownError);
        logger.error(bold(elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
        logger.error(`Failed to create ${nodeModulesBinPath.theNodeModulesBinPath.absolutePath}:\n${error.message}`);
        return 1;
    }
    for (const tool of tools.missing) {
        const dir = absoluteDirname(tool.location.theToolPath);
        try {
            fs.mkdirSync(dir.absolutePath, { recursive: true });
        }
        catch (unknownError) {
            const error = toError(unknownError);
            logger.error(bold(elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
            logger.error(`Failed to create ${dir.absolutePath}:\n${error.message}`);
            return 1;
        }
    }
    const isInteractive = logger.raw.stdout.isTTY;
    const previousProgress = new Map();
    const updateStatusLine = (tool, progress, index) => {
        const formattedProgress = formatProgress(progress);
        const previous = previousProgress.get(index);
        if (previous === formattedProgress) {
            return;
        }
        previousProgress.set(index, formattedProgress);
        const moveCursor = previous !== undefined && isInteractive;
        if (moveCursor) {
            readline.moveCursor(logger.raw.stdout, 0, -tools.missing.length + index);
        }
        logger.log(`${bold(formattedProgress)} ${tool.name} ${tool.version}`);
        if (moveCursor) {
            readline.moveCursor(logger.raw.stdout, 0, tools.missing.length - index - 1);
        }
    };
    logger.log(bold(elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
    for (const [index, tool] of tools.missing.entries()) {
        updateStatusLine(tool, 0, index);
    }
    const presentNames = tools.missing
        .concat(tools.existing)
        .map(({ name }) => name);
    const toolsToRemove = KNOWN_TOOL_NAMES.filter((name) => !presentNames.includes(name));
    const results = [
        ...(await Promise.all(tools.missing.map((tool, index) => downloadAndExtract(env, tool, (percentage) => {
            updateStatusLine(tool, percentage, index);
        }).then(() => {
            updateStatusLine(tool, 1, index);
            return linkTool(cwd, nodeModulesBinPath, tool);
        }, (error) => {
            updateStatusLine(tool, "ERR!", index);
            return new Error(downloadAndExtractError(tool, error));
        })))),
        ...tools.existing.map((tool) => linkTool(cwd, nodeModulesBinPath, tool)),
        ...removeTools(cwd, env, osName, nodeModulesBinPath, toolsToRemove),
    ];
    return printResults(logger, results);
}
function printResults(logger, results) {
    const messages = flatMap(results, (result) => typeof result === "string" ? result : []);
    const installErrors = flatMap(results, (result) => result instanceof Error ? result : []);
    if (isNonEmptyArray(messages)) {
        logger.log(join(messages, "\n"));
    }
    if (isNonEmptyArray(installErrors)) {
        logger.error("");
        logger.error(join(flatMap([
            printNumErrors(installErrors.length),
            ...installErrors.map((error) => error.message),
        ], (item) => (item === undefined ? [] : [item])), "\n\n"));
        return 1;
    }
    return 0;
}
function formatProgress(progress) {
    return typeof progress === "string"
        ? progress.padEnd(4)
        : `${Math.round(progress * 100)
            .toString()
            .padStart(3)}%`;
}
function removeAllTools(cwd, env, logger, osName, elmToolingJsonPath, what) {
    logger.log(bold(elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
    const message = `The "tools" field is ${what}. To add tools: elm-tooling tools`;
    const nodeModulesBinPath = getNodeModulesBinPath(elmToolingJsonPath);
    const results = removeTools(cwd, env, osName, nodeModulesBinPath, KNOWN_TOOL_NAMES);
    if (results.every((result) => result === undefined)) {
        logger.log(message);
        return 0;
    }
    return printResults(logger, results);
}
function removeTools(cwd, env, osName, nodeModulesBinPath, names) {
    return flatMap(names, (name) => {
        const versions = KNOWN_TOOLS[name];
        return Object.entries(versions).map(([version, foo]) => {
            const asset = foo[osName];
            const tool = makeTool(cwd, env, name, version, asset);
            return unlinkTool(cwd, nodeModulesBinPath, tool);
        });
    });
}
async function downloadAndExtract(env, tool, onProgress) {
    return new Promise((resolve, reject) => {
        const removeExtractedAndReject = (error) => {
            try {
                hash.destroy();
                extractor.destroy();
                downloader.kill();
                fs.unlinkSync(tool.location.theToolPath.absolutePath);
                reject(error);
            }
            catch (unknownRemoveError) {
                const removeError = toError(unknownRemoveError);
                if (removeError.code === "ENOENT") {
                    reject(error);
                }
                else {
                    reject(new Error(`${error.message}\n\n${removeError.message}`));
                }
            }
        };
        const hash = crypto.createHash("sha256");
        const extractor = extractFile({
            env,
            assetType: tool.asset.type,
            file: tool.location.theToolPath,
            onError: removeExtractedAndReject,
            onSuccess: resolve,
        });
        let fileSize = 0;
        const downloader = downloadFile(env, tool.asset.url, {
            onData: (chunk) => {
                hash.update(chunk);
                extractor.write(chunk);
                fileSize += chunk.byteLength;
            },
            onProgress,
            onError: removeExtractedAndReject,
            onSuccess: (usedCommand) => {
                const digest = hash.digest("hex");
                if (fileSize !== tool.asset.fileSize) {
                    removeExtractedAndReject(new Error(mismatchError("number of bytes", usedCommand, fileSize, tool.asset.fileSize)));
                }
                else if (digest !== tool.asset.hash) {
                    removeExtractedAndReject(new Error(mismatchError("SHA256 hash", usedCommand, digest, tool.asset.hash)));
                }
                else {
                    extractor.end();
                }
            },
        });
    });
}
function downloadAndExtractError(tool, error) {
    return `
${bold(`${tool.name} ${tool.version}`)}
${indent(`
${dim(`< ${tool.asset.url}`)}
${dim(`> ${tool.location.theToolPath.absolutePath}`)}

${error.message}
  `.trim())}
  `.trim();
}
function downloadAndExtractSimpleError(tool, error) {
    return `
Failed to download:
< ${tool.asset.url}
> ${tool.location.theToolPath.absolutePath}
${error.message}
  `.trim();
}
function mismatchError(expectedString, usedCommand, actual, expected) {
    const extra = typeof usedCommand === "string"
        ? ""
        : `Do you have a config file or environment variables set for ${usedCommand.spawnfile}?`;
    return `
The downloaded file does not have the expected ${expectedString}!
Expected: ${expected}
Actual:   ${actual}

- Probably, something in your environment messes with the download.
- Worst case, someone has replaced the executable with something malicious!

This happened when executing:
${commandToString(usedCommand)}

${extra}
  `.trim();
}
function commandToString(command) {
    // `spawnargs` actually contains `spawnfile` too.
    return typeof command === "string"
        ? command
        : command.spawnargs.map((arg) => (arg === "" ? '""' : arg)).join(" ");
}
function spawn(env, command, args) {
    const { PATH = process.env.PATH } = env;
    return childProcess.spawn(command, args, isWindows && PATH !== undefined
        ? { env: { ...env, PATH: adjustPathForWindows(PATH) } }
        : {});
}
// Git Bash ships with GNU `tar` puts its own stuff first in `$PATH`. But we
// want to run the (BSD) `tar` that ships with Windows, since it supports .zip
// files and handles absolute paths differently. For consistency, we use this
// for _all_ spawns, so that we _always_ use Windows’ own `curl` instead of Git
// Bash’s `curl`.
function adjustPathForWindows(pathString) {
    const [system32, rest] = partitionMap(pathString.split(path.delimiter), (part) => part.toLowerCase().includes("system32")
        ? { tag: "Left", value: part }
        : { tag: "Right", value: part });
    return join([...system32, ...rest], path.delimiter);
}
function downloadFile(env, url, { onData, onProgress, onError, onSuccess, }) {
    let stderr = "";
    const errored = [];
    const onStderr = (chunk) => {
        var _a;
        stderr += chunk.toString();
        // Extract progress percentage from curl/wget.
        const matches = (_a = stderr.match(/\d+(?:[.,]\d+)?%/g)) !== null && _a !== void 0 ? _a : [];
        if (isNonEmptyArray(matches)) {
            callOnProgressIfReasonable(parseFloat(matches[matches.length - 1].replace(",", ".")) /
                100, onProgress);
        }
    };
    const onClose = (command) => (code, signal) => {
        if (errored.includes(command.spawnfile)) {
            return;
        }
        else if (code === 0) {
            onSuccess(command);
        }
        else {
            const trimmed = stderr
                .trim()
                // Remove curl’s progress bar remnants.
                .replace(/^[\s#O=-]+/g, "");
            onError(new Error(`${commandToString(command)}\nThe above command exited with ${exitReason(code, signal)}:\n${trimmed === "" ? EMPTY_STDERR : trimmed}`));
        }
    };
    // `-w ""` overrides `-w "\n"` which people might have in their .curlrc due to this:
    // https://stackoverflow.com/a/14614203/2010616
    // Otherwise they’ll get a byte/hash mismatch due to the extra newline.
    const curl = spawn(env, "curl", ["-#fLw", "", url]);
    let toKill = curl;
    curl.stdout.on("data", onData);
    curl.stderr.on("data", onStderr);
    curl.on("close", onClose(curl));
    curl.on("error", (curlError) => {
        errored.push(curl.spawnfile);
        if (curlError.code === "ENOENT") {
            const wget = spawn(env, "wget", ["-O", "-", url]);
            toKill = wget;
            wget.stdout.on("data", onData);
            wget.stderr.on("data", onStderr);
            wget.on("close", onClose(wget));
            wget.on("error", (wgetError) => {
                errored.push(wget.spawnfile);
                if (wgetError.code === "ENOENT") {
                    toKill = downloadFileNative(url, {
                        onData,
                        onProgress,
                        onError,
                        onSuccess,
                    });
                }
                else {
                    onError(wgetError);
                }
            });
        }
        else {
            onError(curlError);
        }
    });
    return {
        kill: () => {
            toKill.kill();
        },
    };
}
const PROGRESS_UPDATES_PER_SECOND = 50;
function downloadFileNative(url, { onData, onProgress, onError, onSuccess, }, maxRedirects = 50 // This is curl’s default.
) {
    let toKill = {
        kill: () => {
            request.destroy();
        },
    };
    const usedCommand = `require("https").get(${JSON.stringify(url)})`;
    const errorPrefix = `${usedCommand}\nThe above call errored: `;
    const request = https.get(url, (response) => {
        var _a, _b;
        switch (response.statusCode) {
            case 302: {
                const redirect = response.headers.location;
                if (redirect === undefined) {
                    onError(new Error(`${errorPrefix}Got 302 without location header.`));
                }
                else if (maxRedirects <= 0) {
                    onError(new Error(`${errorPrefix}Too many redirects.`));
                }
                else {
                    toKill = downloadFileNative(redirect, {
                        onData,
                        onProgress,
                        onError,
                        onSuccess,
                    }, maxRedirects - 1);
                }
                break;
            }
            case 200: {
                const contentLength = parseInt((_a = response.headers["content-length"]) !== null && _a !== void 0 ? _a : "", 10);
                let length = 0;
                let lastOnProgress = Date.now();
                response.on("data", (chunk) => {
                    length += chunk.length;
                    onData(chunk);
                    const now = Date.now();
                    if (Number.isFinite(contentLength) &&
                        contentLength > 0 &&
                        now - lastOnProgress >= 1000 / PROGRESS_UPDATES_PER_SECOND) {
                        lastOnProgress = now;
                        callOnProgressIfReasonable(length / contentLength, onProgress);
                    }
                });
                response.on("end", () => {
                    onSuccess(usedCommand);
                });
                break;
            }
            default:
                onError(new Error(`${errorPrefix}Unexpected status code: ${(_b = response.statusCode) !== null && _b !== void 0 ? _b : "unknown"}`));
                break;
        }
    });
    request.on("error", onError);
    return {
        kill: () => {
            toKill.kill();
        },
    };
}
function extractFile({ env, assetType, file, onError, onSuccess, }) {
    switch (assetType) {
        case "gz": {
            const gunzip = zlib.createGunzip();
            const write = fs.createWriteStream(file.absolutePath, {
                // Make executable.
                mode: 0o755,
            });
            gunzip.on("error", onError);
            write.on("error", onError);
            write.on("close", onSuccess);
            gunzip.pipe(write);
            return gunzip;
        }
        case "tgz":
            return extractTar({ env, input: "-", file, onError, onSuccess });
        // GNU tar does not support zip files, but only Windows uses zip files and
        // Windows comes with BSD tar which does support them. This could have used
        // the exact same code as for `tgz`, but it somehow fails on Windows:
        // https://stackoverflow.com/questions/63783342/windows-using-tar-to-unzip-zip-from-stdin-works-in-terminal-but-not-in-node-js
        // Workaround: Save the zip to disk, extract it and remove the zip again.
        case "zip": {
            const temp = `${file.absolutePath}.zip`;
            const write = fs.createWriteStream(temp);
            let toDestroy = write;
            let cleanup = () => {
                // If the caller runs `.destroy()` after we’ve already run `cleanup`,
                // don’t run the cleanup procedure again: If the cleanup succeeded
                // there’s nothing to clean; if it failed, running it again will just
                // fail again.
                cleanup = () => undefined;
                try {
                    fs.unlinkSync(temp);
                    return undefined;
                }
                catch (unknownError) {
                    const error = toError(unknownError);
                    return error.code === "ENOENT" ? undefined : error;
                }
            };
            write.on("error", onError);
            write.on("close", () => {
                toDestroy = extractTar({
                    env,
                    input: temp,
                    file,
                    onError: (error) => {
                        const cleanupError = cleanup();
                        onError(cleanupError === undefined
                            ? error
                            : new Error(`${error.message}\n\n${cleanupError.message}`));
                    },
                    onSuccess: () => {
                        const cleanupError = cleanup();
                        if (cleanupError === undefined) {
                            onSuccess();
                        }
                        else {
                            onError(cleanupError);
                        }
                    },
                });
            });
            return {
                destroy: () => {
                    toDestroy.destroy();
                    const cleanupError = cleanup();
                    if (cleanupError !== undefined) {
                        // If cleanup fails, throw the error just like `.destroy()` can.
                        throw cleanupError;
                    }
                },
                write: (chunk) => write.write(chunk),
                end: () => {
                    write.end();
                },
            };
        }
    }
}
function extractTar({ env, input, file, onError, onSuccess, }) {
    const tar = spawn(env, "tar", [
        "zxf",
        input,
        "-C",
        path.dirname(file.absolutePath),
        path.basename(file.absolutePath),
    ]);
    let stderr = "";
    tar.on("error", (error) => {
        if (error.code === "ENOENT") {
            onError(new Error(`tar must be installed on your system and be in ${isWindows ? "%PATH%" : "$PATH"}:\n${error.message}`));
        }
        else {
            onError(error);
        }
    });
    tar.stderr.on("data", (chunk) => {
        stderr += chunk.toString();
    });
    tar.on("close", (code, signal) => {
        if (code === 0) {
            onSuccess();
        }
        else {
            const trimmed = stderr.trim();
            onError(new Error(`${commandToString(tar)}\nThe above command exited with ${exitReason(code, signal)}:\n${trimmed === "" ? EMPTY_STDERR : trimmed}`));
        }
    });
    return {
        destroy: () => {
            // Without destroying stdin, the program exits early with a cryptic EPIPE
            // error – when using `downloadFileNative`.
            tar.stdin.destroy();
            return tar.kill();
        },
        write: (chunk) => tar.stdin.write(chunk),
        end: () => {
            tar.stdin.end();
        },
    };
}
// Without this, you’ll see the progress go up to 100% and then back to 0% again
// when using curl. It reports the progress per request – even redirects. It
// seems to always go from 0% to 100% for redirects (which makes sense – there’s
// no body, only headers). So only report progress _between_ 0% and 100%. It’s
// up to the caller to report 0% before starting and 100% when done.
function callOnProgressIfReasonable(percentage, onProgress) {
    if (percentage > 0 && percentage < 1) {
        onProgress(percentage);
    }
}
function exitReason(code, signal) {
    return code !== null
        ? `exit code ${code}`
        : signal !== null
            ? `signal ${signal}`
            : "unknown reason";
}
async function getExecutable({ name, version, cwd: cwdString = process.cwd(), env = process.env, onProgress, }) {
    const cwd = {
        tag: "Cwd",
        path: absolutePathFromString({ tag: "AbsolutePath", absolutePath: process.cwd() }, cwdString),
    };
    const tool = getToolThrowing({ name, version, cwd, env });
    const exists = validateFileExists(tool.location.theToolPath);
    switch (exists.tag) {
        case "Error":
            throw new Error(exists.message);
        case "Exists":
            return tool.location.theToolPath.absolutePath;
    }
    fs.mkdirSync(absoluteDirname(tool.location.theToolPath).absolutePath, {
        recursive: true,
    });
    onProgress(0);
    let previousPercentage = 0;
    const wrappedOnProgress = (percentage) => {
        if (percentage !== previousPercentage) {
            previousPercentage = percentage;
            onProgress(percentage);
        }
    };
    try {
        await downloadAndExtract(env, tool, wrappedOnProgress);
    }
    catch (unknownError) {
        const error = toError(unknownError);
        throw new Error(removeColor(downloadAndExtractSimpleError(tool, error)));
    }
    wrappedOnProgress(1);
    return tool.location.theToolPath.absolutePath;
}

exports.HIDE_CURSOR = HIDE_CURSOR;
exports.KNOWN_TOOLS = KNOWN_TOOLS;
exports.KNOWN_TOOL_NAMES = KNOWN_TOOL_NAMES;
exports.SHOW_CURSOR = SHOW_CURSOR;
exports.absolutePathFromString = absolutePathFromString;
exports.bold = bold;
exports.dim = dim;
exports.findClosest = findClosest;
exports.findReadAndParseElmToolingJson = findReadAndParseElmToolingJson;
exports.flatMap = flatMap;
exports.fromEntries = fromEntries;
exports.getElmToolingInstallPath = getElmToolingInstallPath;
exports.getExecutable = getExecutable;
exports.getLastVersion = getLastVersion;
exports.getLatestVersionInRange = getLatestVersionInRange;
exports.getOSName = getOSName;
exports.getToolThrowing = getToolThrowing;
exports.install = install;
exports.isNonEmptyArray = isNonEmptyArray;
exports.isRecord = isRecord;
exports.join = join;
exports.printParseErrors = printParseErrors;
exports.removeColor = removeColor;
exports.split = split;
exports.toError = toError;
exports.toJSON = toJSON;
